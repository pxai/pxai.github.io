---
layout: post
title: "Seguridad en Spring" 
date: 2013-07-30 21:58:30 
categories: coding
---
<p>
¿Necesitas aplicar alguna medida de seguridad en Spring? Sin problema. ¿Cansado de implementar una y otra
vez un mecanismo de login/logout en una aplicación web? Spring te lo da hecho. ¿Cómo quieres la validación? Un ficherillo XML,
una base de datos, un ldap, ... tienes varios sabores. Sí, incluso OAuth, en modo backend y con canas ;).
</p>

<p>Aparte de la validación Spring también te facilita enormemente el ACL a distintas partes de la aplicación,
permitiendo aplicar reglas según determinadas URL. En el ejemplo veremos algunas de las opciones.
</p>

<p>
En este ejemplo no vamos a ver código (¡no hace falta!), simplemente veremos dos ficheros XML con los que Spring se basta
para poder aplicar el tema de valiadación y el control de acceso a la aplicación web. 
</p>

<b>web.xml</b>
<p>En la configuración de la aplicación web, aparte del servlet que le da el control a Spring también aplicaremos
otro mecanismo típico de los servlets, los filtros (filters), solo que en este caso es un filter de Spring
que se encarga de todo (por debajo invoca otros filtros etc.. pero eso ya no es nuestro problema).
</p>
<pre class="brush: xml">
<?xml version="1.0" encoding="ISO-8859-1"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5">
  <display-name>seronoser</display-name>
  <context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath:spring/application-config.xml</param-value>
  </context-param>
  <listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
  </listener>
  <servlet>
    <servlet-name>dispatcherServlet</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
      <param-name>contextConfigLocation</param-name>
      <param-value>/WEB-INF/mvc-config.xml</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
  </servlet>
  <filter>
    <filter-name>springSecurityFilterChain</filter-name>
    <filter-class>
            org.springframework.web.filter.DelegatingFilterProxy
        </filter-class>
  </filter>
  <filter-mapping>
    <filter-name>springSecurityFilterChain</filter-name>
    <url-pattern>/*</url-pattern>
  </filter-mapping>
  <servlet-mapping>
    <servlet-name>dispatcherServlet</servlet-name>
    <url-pattern>/</url-pattern>
  </servlet-mapping>
</web-app>
</pre>

<b>aplication-config.xml</b><p>
En este fichero de configuración de contexto de Spring es donde vamos a meter toda la chicha. Lo primero que
debemos incluir el soporte para los tags relacionados con security. En la mayoría de ejemplos que se ven
por ahí, incluso en los oficiales, se declara el security como XMLns por defecto, con el objeto de no tener
que poner el prefijo en cada etiqueta suya. Eso obliga a poner el prefijo beans a quienes corresponde, incluido
el raíz. En mi caso, para probar que no pasaba nada por hacerlo como hasta ahora lo dejo a lo pesado, y he tenido
que poner el prefijo security: a toda etiqueta que lo necesitaba. En fin, echemos un ojo, el XML está automentado
y creo que no necesita mucha explicación.</p>
<pre class="brush: xml">
<?xml version="1.0" encoding="UTF-8"?>
<!-- 
PAY ATTENTION!!! If you don't want to put security: prefix in every security-related
tag you must config as default namespace and change beans to xmlns:beans
-->
<beans 
	xmlns="http://www.springframework.org/schema/beans" 
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:security="http://www.springframework.org/schema/security"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
		http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security-3.1.xsd">

  <!--
  	If we put auto-config="true" as http attribute
  	auto-config generates login and logout pages, remember-me feature,... for us.
  	We also set interceptions or not based on url patterns
  -->
  <security:http  use-expressions="true">
    <security:intercept-url pattern="/css/**" access="permitAll" />
    <security:intercept-url pattern="/js/**" access="permitAll" />
    <security:intercept-url pattern="/images/**" access="permitAll" />
    <security:intercept-url pattern="/hello" access="permitAll" />

    <security:intercept-url pattern="/protected" access="isAuthenticated()" />

    <security:intercept-url pattern="/admin/**" 
        access="isAuthenticated() and principal.username=='root'"/>
     <!-- the same but for all the role -->
    <security:intercept-url pattern="/admin" access="hasRole('admin')"/>
        <!-- This is radical but recommended -->
        <security:intercept-url pattern="/**" access="denyAll" />

        <security:form-login />
        <security:logout />

	<!-- In case qe want to force https in login -->        
    <!--security:intercept-url pattern="/login" requires-channel="https"/ -->

	<!-- Another way to be more specific -->
    <!-- security:form-login login-page="/login"
                login-processing-url="/static/j_spring_security_check"  
                authentication-failure-url="/login"/>
    <security:logout logout-url="/static/j_spring_security_logout"/ -->

    <security:remember-me key="seronoserkey"
        token-validity-seconds="2419200" />    
   </security:http>
   
   <!-- We set the authentication manager -->
     <security:authentication-manager alias="authenticationManager">
    	<security:authentication-provider user-service-ref="xmlUserService" />
  	</security:authentication-manager>
  	
  	<!-- Plain user/password xml database -->
  	<security:user-service id="xmlUserService">
      <security:user name="root" password="toor"  authorities="normal, admin"/>
      <security:user name="falken" password="josua"  authorities="normal"/>
      <security:user name="snowden" password="secret" authorities="normal"/>
    </security:user-service>    
    <!-- In case we wanted jdbc based authentication
    	We need a datasource and also specify queries for auth. 
    -->
        <!-- security:jdbc-user-service id="jdbcUserService" 
       data-source-ref="dataSource"
       users-by-username-query="select username, password, true from users where username=?"
       authorities-by-username-query="select username,'admin' from users where username=?" / -->

</beans>
</pre>
<p>Como se puede ver hay una serie de reglas de acceso basadas en la URL que se permiten o deniegas a todos
o según usuario, según rol/grupo o según si hay usuario validado o no. 
Otra de las cosas muy útiles de Spring es que te genera de forma automática la pantalla y el mecanismo de login, de logout
e incluso el mecanismo de remember-me por si no quieres que el usuario se esté validando todo el rato.
</p>
<img src="http://www.pello.info/images/springlogin.png" alt="Login generado por Spring" title="Login generado por Spring" />
<p>La seguridad de Spring también te facilita el tema de la validación de usuarios pudiendo gestionar
los usuarios/roles en el propio xml, por jdbc (debes indicar un Datasource y las queries de validación),
LDAP, etc..
</p>

<b>Más cosas</b><br />
<p>También podemos aplicar el control de acceso sobre métodos java aplicando anotaciones propias
de Spring o las Estándar. Si metemos esto</p>
<pre class="brush: xml">
<global-method-security secured-annotations="enabled" />
</pre>
<p>Ahora ya podriamos poner delante de los métodos java anotaciones como @Secured({"admin"}) o @RollesAllowed
si usamos las estándar. Aparte de eso también podemos meter anotaciones para controlar el acceso
previo/posterior a los métodos, basándonos por ejemplo en el resultado del mismo o en condiciones previas.</p>

<b>A tener en cuenta, en general con Spring</b>
<p>Meter la seguridad es muy simple, pero claro puede que la aplicación te esté cascando y no sepás
por qué, sobre todo cuando las aplicaciones se van complicando, usan el MVC, usan mil y una librerías/frameworks
y se montan con otro framework. A veces puedes tener la sensación de que en teoría usas herramientas
para facilitar le desarrollo y mantenimiento pero te hacen trabajar el doble.</p>
<p>La verdad es que se montan tinglados bastante complejos y basta con meter la pata en un fichero
xml, con no cumplir una dependencia, con no ejecutar Maven correctamente para que el castillo se venga abajo.
En estas situaciones la consola será tu mejor amiga, y cuando una excepción te empiece a vomitar stack traces nada
mejor que ir a la primera de todas para saber el error. En los blogs con ejemplos de Spring/Maven etc.. todo 
parece muy bonito, pones esto, lo otro y a correr, pero no señor, no te dan los detalles de cómo se
hace el build y lo que en su entorno va bien en el tuyo puede cascar sin remedio</p>
<p>Con aplicaciones Web Spring montadas con Maven, al menos en mi caso, con el Eclipse Kepler y el plugin de
spring, generando un proyecto Spring Web Maven <a href="http://www.pello.info/index.php/blog/creando-un-proyecto-web-spring-mvc">como expliqué aquí</a>, las cosas suelen ir rodadas. Lo único
que tendrás que hacer es ir añadiendo dependencias a Maven</p>
<p>Y en fin, si quieres ver cómo monté esto, tienes el <a href="http://code.google.com/p/erps-2dam-4vientos/source/browse/SecuritySpringMvc/">proyecto en google code</a></p> 